{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Projects \u00b6 This site compiles many of my personal projects, which range from algorithm implementations to completed games. My personal development time is often split 50/50 between long-term game projects and short term experiments & exercises. History \u00b6 I've been working on independent & personal projects since 2010. My habit so far has been to post clips and screenshots to social media and then let them sit in my github account until I need to reference them, but I'm hoping to collect & curate them here for interested parties. I also hope to take many of my longer development threads from Twitter and recreate them in this site, for archive's sake. Note that not all projects include source. The simplest of these projects is often implementing something interesting I've seen, just to feel out the algorithm and to understand it beyond the theoretical. Wave Function Collapse Experiments is a great example of this. At the other end of the spectrum are larger projects that I work on for months or years at a time. My Node Mapping tool & beholdin fit best under this category","title":"Projects"},{"location":"#projects","text":"This site compiles many of my personal projects, which range from algorithm implementations to completed games. My personal development time is often split 50/50 between long-term game projects and short term experiments & exercises.","title":"Projects"},{"location":"#history","text":"I've been working on independent & personal projects since 2010. My habit so far has been to post clips and screenshots to social media and then let them sit in my github account until I need to reference them, but I'm hoping to collect & curate them here for interested parties. I also hope to take many of my longer development threads from Twitter and recreate them in this site, for archive's sake. Note that not all projects include source. The simplest of these projects is often implementing something interesting I've seen, just to feel out the algorithm and to understand it beyond the theoretical. Wave Function Collapse Experiments is a great example of this. At the other end of the spectrum are larger projects that I work on for months or years at a time. My Node Mapping tool & beholdin fit best under this category","title":"History"},{"location":"Experiments/Markov%20Jr/","text":"Inspired by mxgmn , I implemented a simple set of rules of Markov Jr in Godot. Markov Jr needs some boilerplate work to make nodes operate in any nonlinear way (hiearchies, subgraphs, etc). I opted out of doing this work unless I could complete the work to make inference work, which allows user to enforce constraints on a sequence to varying effects. I never go that far, but my implementation was enough to generate mazes and flood fills. It is my hope to revisit Markov Jr as part of the Godot port of my Node Mapping project. A flood fill is a very simple markovjr ruleset w/ 2 rules. see the video here . With only 3 rules and no code changes, you can implement the entirety of a backtrack maze algorithm. video here .","title":"Markov Jr"},{"location":"Experiments/Wave%20Function%20Collapse%20Experiments/","text":"Inspired by mxgmn & Oskar St\u00e5lberg , I spent a bunch of time building out a Unity implementation for WFC using tilemaps. This was a fun exercising in optimization, and taught me a lot about how procedural generation can still leave room for authored editing: to me, the strength of WFC is allowing both the designer and the algorithm to \"collapse\" any of the nodes, opening up myriad ways to collaborate with the machine. Source for WFC is closed. The code is not documented well enough to be of any use to anyone, but interested parties can reach out if they want to learn more. As usual, it's worth noting that performance in these clips is often bound by screen capture / streaming, and staggered execution is an intentional choice to make the videos more interesting! Staggered Fill on YouTube - In this clip, each contiguous island can be clicked on to destroy the island, and then refill via WFC. each new island is covered based on it's center point's distance to the middle of the square. I started off with a simple generator using a basic pipe tileset But ended up making a more complex pipes set with overpasses, endings and other features. I fell in love with the pictures I could find in the chaos. fullsized asset here . I began constraining the generation within shapes by selectively allowing regions Which lead to interactions like the following clips, where the user could select a region manually to trigger rebuilds of the WFC. radial_sample.mp4 gameplay_destruction.mp4","title":"Wave Function Collapse Experiments"},{"location":"Games/GodotRL/","text":"GodotRL (not the final name) is a Roguelike I'm slowly chipping away at as I learn Godot. I challenge myself to write large systems and keep them working together harmoniously, as well as make the design accessible. Some tweets are available here for now. Completed Features \u00b6 A threaded implementation of Dijkstra Maps , which may need to be ported to GDScript 2.0 or C# in the future. Radial FoV by way of Bresenham's algorithm , performed in octants A Command Queue action system with full interrupt, divert and undo support. Deterministic map generation with serializable settings, for consistent reproduction of a level across plays (handy for repro cases) Several move abilities, including in range , explicit points and explicit paths A thoughtful energy system where abilities energy costs determine how long until the next turn. A Turn order bar that accurately shows the turn order and a preview of how each abilities energy cost affects turn order. Entities mix and match 2 aspects from a pool to determine appearance and abilities Auto Explore mode, where the player auto explores the map until it is fully explored or something interesting happens Upcoming \u00b6 A token system to act as a foundational mechanic for combat Undo support for the logger Peek view for inspecting anything you'd wish ...and more! here's a recent clip","title":"GodotRL"},{"location":"Games/GodotRL/#completed-features","text":"A threaded implementation of Dijkstra Maps , which may need to be ported to GDScript 2.0 or C# in the future. Radial FoV by way of Bresenham's algorithm , performed in octants A Command Queue action system with full interrupt, divert and undo support. Deterministic map generation with serializable settings, for consistent reproduction of a level across plays (handy for repro cases) Several move abilities, including in range , explicit points and explicit paths A thoughtful energy system where abilities energy costs determine how long until the next turn. A Turn order bar that accurately shows the turn order and a preview of how each abilities energy cost affects turn order. Entities mix and match 2 aspects from a pool to determine appearance and abilities Auto Explore mode, where the player auto explores the map until it is fully explored or something interesting happens","title":"Completed Features"},{"location":"Games/GodotRL/#upcoming","text":"A token system to act as a foundational mechanic for combat Undo support for the logger Peek view for inspecting anything you'd wish ...and more! here's a recent clip","title":"Upcoming"},{"location":"Games/beholdin/","text":"beholdin' is a coffee break twin stick shooter; a daily challenge score chaser that rewards the risky and creative players. You can find it on itch . I finished the game around 2018 after about 1.5 years of commutes. Call it 10 hours a week, about 70 weeks to be generous, that's 700 hours. Its rough around the edges, but I love it and will probably dedicate some time to making it more robust in the future. I kept a devlog alongside releases that some parties might find interesting. Oddly enough, the best visual story of the game's development is probably this moment on Twitter (for now). Features \u00b6 a single procedurally generated level every day. a unique level skin (biome?) for each day of the week. a unique combination of enemies & mechanics for each day of the week. in each room, every wave triggered increases your multiplier, each hit you take decreases it. player-paced risk vs reward: break each crystal one at a time to deal with each wave in isolation, or break 'em all at once and hope you can handle it for max score. leaderboards, for bragging rights. Reflective walls, gravity wells, shields, lasers, bombs & turrets: all the classics make an appearance. Technical Notes \u00b6 Lasers are ray-marched so they could be reflected by reflectors, but also get their trajectory bent by gravity wells (push & pull) all of the gameplay art was made in-unity with custom tools to make meshes out of polygons. each vertex of the art meshes stores a UV lookup value into a gradient palette that you can swap as you please (try hitting space while you're playing the game!) the game was made almost entirely on my train commute to and from work. GameSparks & Playfab integration required some evening work. each audio track was made in Gadget on my iPad. elements of the songs are ducked in and out based on whether a room has unbroken crystals, active combat, if a room has a boss, and more.","title":"Beholdin"},{"location":"Games/beholdin/#features","text":"a single procedurally generated level every day. a unique level skin (biome?) for each day of the week. a unique combination of enemies & mechanics for each day of the week. in each room, every wave triggered increases your multiplier, each hit you take decreases it. player-paced risk vs reward: break each crystal one at a time to deal with each wave in isolation, or break 'em all at once and hope you can handle it for max score. leaderboards, for bragging rights. Reflective walls, gravity wells, shields, lasers, bombs & turrets: all the classics make an appearance.","title":"Features"},{"location":"Games/beholdin/#technical-notes","text":"Lasers are ray-marched so they could be reflected by reflectors, but also get their trajectory bent by gravity wells (push & pull) all of the gameplay art was made in-unity with custom tools to make meshes out of polygons. each vertex of the art meshes stores a UV lookup value into a gradient palette that you can swap as you please (try hitting space while you're playing the game!) the game was made almost entirely on my train commute to and from work. GameSparks & Playfab integration required some evening work. each audio track was made in Gadget on my iPad. elements of the songs are ducked in and out based on whether a room has unbroken crystals, active combat, if a room has a boss, and more.","title":"Technical Notes"},{"location":"Tools/Node%20Mapping/","text":"I built a node-based mapping library for Unity, using the xNode plugin for the graph tooling. I build a lot of grid-based games and was hoping to create a Shader-Graph-like solution for generating tile maps. This tool is open sourced here . I kept a fairly active Twitter thread while working on this project as well. Needs \u00b6 When generating maps in a code-driven way, you often need to layer and combine noise patterns in a variety of ways, testing and tweaking as you go. This iterative process can be slow when changing code every test - or time consuming and unwieldy to expose all of the appropriate elements to the inspector. Compounding this is that rather than a singular result, you are often building something robust that can be generated in a multitude of ways, so each iteration needs to be tested with some set of changing parameters: often seed , but also map_size and other elements. Solution \u00b6 The Node Graph workflow lends itself well to these needs: you can preview your map generator at multiple steps in the generation, as well as across multiple seeds. Live Preview can be made to react to scrubbing of value, and pieces of the genreator can be detached from others to isolate elements that need fixing. Present & Future \u00b6 The tool is open sourced here . I intend to rebuild it in Godot 4, as a GraphEdit and Noise refactor are slated to be delivered. Another strngeth of this tool is combining procedural methods from different domains: like experiementing with cellular automation applied to the ouput of traditional perlin noise This clip shows what it looks liek to tweak how a Minimum Spanning Tree is connected, but also how the tool stores and renders that data. Quick gif that shows how scrubbing the seed param allows you to view many outputs of a graph I wrote a couple of different consumers for the output, including a 3d terrain plugin.","title":"Node Mapping"},{"location":"Tools/Node%20Mapping/#needs","text":"When generating maps in a code-driven way, you often need to layer and combine noise patterns in a variety of ways, testing and tweaking as you go. This iterative process can be slow when changing code every test - or time consuming and unwieldy to expose all of the appropriate elements to the inspector. Compounding this is that rather than a singular result, you are often building something robust that can be generated in a multitude of ways, so each iteration needs to be tested with some set of changing parameters: often seed , but also map_size and other elements.","title":"Needs"},{"location":"Tools/Node%20Mapping/#solution","text":"The Node Graph workflow lends itself well to these needs: you can preview your map generator at multiple steps in the generation, as well as across multiple seeds. Live Preview can be made to react to scrubbing of value, and pieces of the genreator can be detached from others to isolate elements that need fixing.","title":"Solution"},{"location":"Tools/Node%20Mapping/#present-future","text":"The tool is open sourced here . I intend to rebuild it in Godot 4, as a GraphEdit and Noise refactor are slated to be delivered. Another strngeth of this tool is combining procedural methods from different domains: like experiementing with cellular automation applied to the ouput of traditional perlin noise This clip shows what it looks liek to tweak how a Minimum Spanning Tree is connected, but also how the tool stores and renders that data. Quick gif that shows how scrubbing the seed param allows you to view many outputs of a graph I wrote a couple of different consumers for the output, including a 3d terrain plugin.","title":"Present &amp; Future"},{"location":"Tools/Other%20Tools/","text":"I'm in the process of moving these articlesto this new format, but for now you can find some of my old tools elsewhere. Keep in mind some of these tools are as old as 2017 and are here for historical reasons, not because the problem they solve is still a problem. Generating Animators - This is a small Unity tool to generate an Animator & Animations from a folder structure. Its not a compelte solution, just automating some of the more annoying work. Simple Whitelist RuleTile - Extremely handy for projects using lots of RuleTiles with Unity's Tilemap system. Often a ruletile should count another type as its own to correctly handle edges with different tiles. this is a simple implementation to have a rule tile treat another ruletile as itself. RPGMaker Autotile Asset Pipeline in Unity - Another handy tool for using tilemaps in Unity, this tool correctly imports RPGMaker's A2 tile assets into Unity's Ruletile system. The mapping used here is twice the resolution of the actual tile, as RPGMaker actually tiles these at twice the resolution: The tiles that work for a 16x16 world are actually broken into 8x8 to manager all corner combos. Also handy is that the mapping is defined by a scriptable object, so you can make an autoimporter for a different source layout. Unity Depth Capture for Facebook - Quick tools that captures a screenshot and the depth buffer from Unity, auto formatted to work as a Facebook 3D photo upload. SpriteMaker - An older tool I built to handle generating smaller UI & Utility sprites directly from inside Unity. PaletteSwapper - Another older tool allowing you to manually swap asset palettes right in Unity.","title":"Other Tools"}]}